---
/**
 * Minimal Transfer Calculator Component
 *
 * Barebones implementation with essential functionality only
 * Connected to exchange and countries APIs
 */
import { getRemittanceRates } from '@helpers/remittance-exchange';
import { triggerAppRedirect } from '@util/handleAppRedirect';

interface Props {
  initialSendAmount?: number;
  initialSendCurrency?: string;
  initialReceiveCurrency?: string;
}

const { initialSendAmount = 1000, initialSendCurrency = 'AED', initialReceiveCurrency = 'USD' } = Astro.props;

// Get initial exchange rate data
const exchangeData = await getRemittanceRates('AE', {
  quotation_mode: 'SEND_AMOUNT',
  receive: {
    country_code: initialReceiveCurrency === 'INR' ? 'IN' : initialReceiveCurrency === 'PKR' ? 'PK' : 'US',
    currency: initialReceiveCurrency,
  },
  send: {
    amount: initialSendAmount,
    currency: initialSendCurrency,
    country_code: 'AE',
  },
});

// Check if we got an API error
const isApiError = exchangeData && exchangeData.__apiError === true;

// Extract values from exchange data
const sendAmount = initialSendAmount.toString();
const sendCurrency = initialSendCurrency;
const receiveAmount = isApiError ? '0.00' : exchangeData.receive.amount.toFixed(2);
const receiveCurrency = initialReceiveCurrency;
const transferFee = isApiError ? 'N/A' : `${exchangeData.fee.amount.toFixed(2)} ${exchangeData.fee.currency}`;
const exchangeRate = isApiError
  ? 'N/A'
  : `1.00 ${sendCurrency} = ${exchangeData.quotations[0]?.transfer_fx_rate.toFixed(4)} ${receiveCurrency}`;

// Extract supported countries if available in the API response
let supportedCountries: Array<{ code: string; currency: string; name: string; flag: string }> = [];
if (exchangeData.countries) {
  const countries = exchangeData.countries as Record<string, any>;
  supportedCountries = Object.entries(countries).map(([code, data]) => ({
    code,
    currency: data.currency as string,
    name: data.name as string,
    flag: (data.unicode as string) || getFlagEmojiFromCode(code),
  }));
} else if (exchangeData.supported_countries) {
  const countries = exchangeData.supported_countries as Record<string, any>;
  supportedCountries = Object.entries(countries).map(([code, data]) => ({
    code,
    currency: data.currency as string,
    name: data.name as string,
    flag: (data.unicode as string) || getFlagEmojiFromCode(code),
  }));
}

// If no countries found, add common fallback currencies
if (supportedCountries.length === 0) {
  supportedCountries = [
    { code: 'US', currency: 'USD', name: 'United States', flag: 'üá∫üá∏' },
    { code: 'IN', currency: 'INR', name: 'India', flag: 'üáÆüá≥' },
    { code: 'PK', currency: 'PKR', name: 'Pakistan', flag: 'üáµüá∞' },
    { code: 'PH', currency: 'PHP', name: 'Philippines', flag: 'üáµüá≠' },
  ];
}

// Helper function to get flag emoji from country code
function getFlagEmojiFromCode(countryCode: string): string {
  if (!countryCode) return 'üåê';
  const flagMap: Record<string, string> = {
    US: 'üá∫üá∏',
    IN: 'üáÆüá≥',
    PK: 'üáµüá∞',
    BD: 'üáßüá©',
    PH: 'üáµüá≠',
    LK: 'üá±üá∞',
    NP: 'üá≥üáµ',
    EG: 'üá™üá¨',
    JO: 'üáØüá¥',
    TH: 'üáπüá≠',
  };
  return flagMap[countryCode] || 'üè≥Ô∏è';
}
---

<div class='p-4 bg-gray-100 rounded-lg calculator-container'>
  <!-- Send section -->
  <div class='mb-4'>
    <label for='send-amount' class='block mb-2 text-sm'>You send:</label>
    <div class='flex items-center justify-between p-3 bg-white border rounded-lg'>
      <input type='text' id='send-amount' value={sendAmount} class='text-lg focus:outline-none' data-send-input />
      <span id='send-currency' data-send-currency>{sendCurrency}</span>
    </div>
  </div>

  <!-- Receive section -->
  <div class='mb-4'>
    <label for='receive-amount' class='block mb-2 text-sm'>Recipient receives:</label>
    <div class='flex items-center justify-between p-3 bg-white border rounded-lg'>
      <input
        type='text'
        id='receive-amount'
        value={receiveAmount}
        class='text-lg focus:outline-none'
        readonly
        data-receive-input
      />
      <div class='relative'>
        <button type='button' id='currency-dropdown-btn' class='flex items-center' aria-expanded='false'>
          <span id='receive-currency-text'>{receiveCurrency}</span>
          <svg xmlns='http://www.w3.org/2000/svg' class='w-4 h-4 ml-1' viewBox='0 0 20 20' fill='currentColor'>
            <path
              fill-rule='evenodd'
              d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z'
              clip-rule='evenodd'></path>
          </svg>
        </button>
        <div id='currency-dropdown' class='absolute right-0 z-10 hidden mt-1 bg-white border rounded shadow-lg'>
          <!-- Currency options will be populated by JS -->
        </div>
      </div>
    </div>
  </div>

  <!-- Transfer details -->
  <div class='mb-4 text-sm'>
    <div class='flex justify-between mb-1'>
      <span>Transfer fee:</span>
      <span id='transfer-fee'>{transferFee}</span>
    </div>
    <div class='flex justify-between'>
      <span>Exchange rate:</span>
      <span id='exchange-rate'>{exchangeRate}</span>
    </div>
  </div>

  <!-- Send button -->
  <button id='send-btn' type='button' class='w-full p-3 text-white bg-black rounded-lg hover:bg-gray-800'>
    Send money now
  </button>
</div>

<script
  define:vars={{
    supportedCountries,
    sendAmount,
    sendCurrency,
    receiveAmount,
    receiveCurrency,
    transferFee,
    exchangeRate,
  }}
>
  // Import encryption helper for client-side use
  /**
   * RSA/AES encryption helpers using browser-native Web Crypto API
   *
   * Browser-native implementation that doesn't require external dependencies.
   * Uses Web Crypto API for RSA-OAEP encryption with the same security standards
   * as the original jose implementation.
   */

  /**
   * Check if Web Crypto API is available
   * @returns {boolean}
   */
  function isWebCryptoAvailable() {
    return typeof crypto !== 'undefined' && crypto.subtle && typeof crypto.subtle.importKey === 'function';
  }

  /**
   * Convert base64url to ArrayBuffer
   * @param {string} base64url
   * @returns {ArrayBuffer}
   */
  function base64urlToArrayBuffer(base64url) {
    // Convert base64url to base64
    const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
    // Add padding if needed
    const padded = base64 + '==='.slice(0, (4 - (base64.length % 4)) % 4);
    // Decode base64 to binary string
    const binary = atob(padded);
    // Convert to ArrayBuffer
    const buffer = new ArrayBuffer(binary.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
      view[i] = binary.charCodeAt(i);
    }
    return buffer;
  }

  /**
   * Convert ArrayBuffer to base64url
   * @param {ArrayBuffer} buffer
   * @returns {string}
   */
  function arrayBufferToBase64url(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    const base64 = btoa(binary);
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  }

  const PRIVATE_KEY_CONFIG = {
    d: 'F0fITN6nNTqLoIaO5SEn2fEy7z_8lrfuzd428_oWZVl9U6H3LPUf7_vqo8w0PVezgLmfBysMPc0pTjIKGQqAsokd9FeQuqgfHRLBS8vkdfSQ39UyuKe3l4PI8iyGc5RuqjwN8Yl8U-4K010fFTrw1mphJ4YeeOUu09a6CfMzgXEF0eQNiR1DOK4SJfyqNi4S_w9j7TMSMKjnZ9Sloqs9GxM8CYwzy9Ezn4sj_WeTmPUd2aH39xlyadufv0Gt-rwWtJOLV-Z_SB0VW2wMIZ_vBwSQyGnl1RvdWdWbswJflTOm8ypoZkH8L_jee3DkoO3NjisMrKpbjifYRZhRakw69w',
    dp: 'lnqgUop27gsizChe_YfxHPQB0it6OyOZVu4-QGNt6lYGBjDaigy6qez32IxE80WpPAHHhf26FNFiIQi5KNPKOuOCjCIbs_z9xfjnRCeCBPAWJ2GDyOXs-MFDmzbrZmweslLhKJHPcidEiRkLNYpRar9_PeCoRg71WgUCXVq_T8s',
    dq: 'q9LDRs4IXm0opQRJ4FffWZJbMcy_RNbR9K-chfX0BNh4ZpWPPU6iDoQA3AysTU76Pn3NLDTuSofxt8uCRfbXYFnu-ojJj0vWI2Z-AgLPi3uXdlhBvS-IvqaENE5yltjZpNi_fouTbLBjBFxrNO9DhCtxwZhntHd3UTXLqZCVUKk',
    e: 'AQAB',
    kty: 'RSA',
    n: 'jiIRvCBjTToaYMHTUxnKoTdKGHdtuymLWl-s3oeiZ9tWXqMeOdbiCYMSzC-N8kkpu5sdmknkVROeKKVS3OvmyxBuZ6hDfwAyfdg0t8273JX6Z7fZH6tL7T2HHJ4ItQesTuhPmJR5_oGiPO5mDjC5SUd5otrbKqUAAy9fLtT5_l91uUc27bZGvkL9Tzi9EHNeA_LgnYRNohOygirKx1G-hdGVWoisVIdiIY7Hc_XaViCCNwhiEELN4iS4MOD4Suut7Y6V5l_PmSCnUcn6-R194edIKHd7TiiFQrkNab2gb16Qdu8fCO41OdRlF_ifvWWxtqHeW3eqRdDYwaBxDvlsnQ',
    p: 'xZUoijVBi42hGdxkANXuRM4da6B7IMxw_i_2JTv-nS5CdjIIAXkvTBNQebhgi2Wkek89TgsBzZR2KYx04skPK3Ie7PMMcsn0jqOMF3vznF22ByXkshsEvMwCi-Dz4IGFdkakpVnqTfFa9p32UdBt03RxIW9YN05vAVSKwoE4tps',
    q: 'uCf8fWbEr8q1o5TRv96BlqxWw1P8qEq3fJT60LPDOQov21nEfu1-IznbDtf2D58JjTAYBcT_JMi9B9emcntopNsJyCIt87sYXNO-2_LgoIrwc2n8xiWjDPmqRV_EZ87En_hhwv1P5cIBDuKTNIsYperkGudOAfj7f4K5lE5NASc',
    qi: 'G-4RzwYCbCbPPZP6XXzO5WhYyYmp_hA7heRfV7bQMluN2VPhr1uyYSpH_gDjnR1cBea5Tl9bgPIDrQ-NUpWp00pGa4LJ-VhOByy0pRp-SB47-VbL9CfpV9gVmeDBkOST0ABo4jYbFZd341Pj3eq9UwHKzWrJVlz0NYWTT-yb3l4',
  };

  const PUBLIC_KEY_CONFIG = {
    kty: 'RSA',
    e: 'AQAB',
    n: 'jiIRvCBjTToaYMHTUxnKoTdKGHdtuymLWl-s3oeiZ9tWXqMeOdbiCYMSzC-N8kkpu5sdmknkVROeKKVS3OvmyxBuZ6hDfwAyfdg0t8273JX6Z7fZH6tL7T2HHJ4ItQesTuhPmJR5_oGiPO5mDjC5SUd5otrbKqUAAy9fLtT5_l91uUc27bZGvkL9Tzi9EHNeA_LgnYRNohOygirKx1G-hdGVWoisVIdiIY7Hc_XaViCCNwhiEELN4iS4MOD4Suut7Y6V5l_PmSCnUcn6-R194edIKHd7TiiFQrkNab2gb16Qdu8fCO41OdRlF_ifvWWxtqHeW3eqRdDYwaBxDvlsnQ',
  };

  const ALGORITHM = {
    name: 'RSA-OAEP',
    hash: 'SHA-256',
  };

  /**
   * Convert JWK to CryptoKey using Web Crypto API
   * @param {Object} jwk - JSON Web Key object
   * @param {Array<string>} keyUsages - Key usage array
   * @returns {Promise<CryptoKey>}
   */
  async function importJWK(jwk, keyUsages) {
    if (!isWebCryptoAvailable()) {
      throw new Error('Web Crypto API not available');
    }

    return await crypto.subtle.importKey(
      'jwk',
      jwk,
      ALGORITHM,
      false, // extractable
      keyUsages
    );
  }

  async function getPublicKey() {
    if (!isWebCryptoAvailable()) return null;
    return await importJWK(PUBLIC_KEY_CONFIG, ['encrypt']);
  }

  async function getPrivateKey() {
    if (!isWebCryptoAvailable()) return null;
    return await importJWK(PRIVATE_KEY_CONFIG, ['decrypt']);
  }

  /**
   * Encrypt request data for the remittance-exchange API.
   * Uses Web Crypto API for RSA-OAEP encryption. Falls back to plain JSON if crypto is unavailable.
   * @param {any} data
   * @returns {Promise<string>}
   */
  async function encryptRequest(data) {
    if (!isWebCryptoAvailable()) {
      console.warn('[encryption] Web Crypto API not available ‚Äì falling back to plain JSON.');
      return JSON.stringify(data);
    }

    try {
      const rsaPublicKey = await getPublicKey();
      if (!rsaPublicKey) {
        console.warn('[encryption] Could not load public key ‚Äì falling back to plain JSON.');
        return JSON.stringify(data);
      }

      // Convert data to ArrayBuffer
      const jsonString = JSON.stringify(data);
      const dataBuffer = new TextEncoder().encode(jsonString);

      // Encrypt with RSA-OAEP
      const encryptedBuffer = await crypto.subtle.encrypt(ALGORITHM, rsaPublicKey, dataBuffer);

      // Convert to base64url for transport
      return arrayBufferToBase64url(encryptedBuffer);
    } catch (error) {
      console.error('[encryption] Encryption failed:', error);
      console.warn('[encryption] Falling back to plain JSON.');
      return JSON.stringify(data);
    }
  }

  /**
   * Decrypt response data from the API.
   * Uses Web Crypto API for RSA-OAEP decryption. Falls back to JSON parsing if crypto is unavailable.
   * @param {string} data
   * @returns {Promise<any>}
   */
  async function decryptResponse(data) {
    if (!isWebCryptoAvailable()) {
      console.warn('[encryption] Web Crypto API not available ‚Äì assuming plain JSON.');
      return JSON.parse(data);
    }

    try {
      const rsaPrivateKey = await getPrivateKey();
      if (!rsaPrivateKey) {
        console.warn('[encryption] Could not load private key ‚Äì assuming plain JSON.');
        return JSON.parse(data);
      }

      // Convert base64url to ArrayBuffer
      const encryptedBuffer = base64urlToArrayBuffer(data);

      // Decrypt with RSA-OAEP
      const decryptedBuffer = await crypto.subtle.decrypt(ALGORITHM, rsaPrivateKey, encryptedBuffer);

      // Convert back to string and parse JSON
      const jsonString = new TextDecoder().decode(decryptedBuffer);
      return JSON.parse(jsonString);
    } catch (error) {
      console.error('[encryption] Decryption failed:', error);
      console.warn('[encryption] Assuming data is plain JSON.');
      return JSON.parse(data);
    }
  }

  /**
   * Client-side API helper functions
   */

  /**
   * Get remittance exchange rates from API
   *
   * @param {string} country - Country code (e.g., 'AE', 'BH')
   * @param {Object} exchangeRequest - Exchange request parameters
   * @returns {Promise<Object>} - Exchange rate response
   */
  async function getRemittanceRatesClient(country, exchangeRequest) {
    console.log('[Client API] Starting remittance API request:', country, exchangeRequest);

    // Select API endpoint based on country
    const apiUrl =
      country === 'BH'
        ? 'https://bh-api.jinglepay.dev/api/v0/remittance/rates-review/'
        : 'https://api.jinglepay.dev/api/v0/remittance/rates-review/';

    try {
      console.log(`[Client API] Making request to ${apiUrl}`);

      // Make API call with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
        body: await encryptRequest(exchangeRequest),
        credentials: 'include',
        mode: 'cors',
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        console.error('[Client API] Error response:', response.status, response.statusText);
        throw new Error(`API error: ${response.status}`);
      }

      const result = await response.json();
      console.log('[Client API] Response received:', result);
      return result;
    } catch (error) {
      console.error('[Client API] Request failed:', error);

      // Return mock data for error case so UI can continue
      return {
        __apiError: true,
        errorMessage: error.message || 'Failed to fetch rates',
        // Basic mock data structure so UI doesn't break
        send: { amount: 0, currency: 'AED' },
        receive: { amount: 0, currency: exchangeRequest.receive.currency },
        fee: { amount: 0, currency: 'AED' },
        quotations: [
          {
            transfer_fx_rate: 0,
            provider: 'Unknown',
          },
        ],
      };
    }
  }

  /**
   * Redirect to app for transfer
   * Simplified client-side version
   */
  function triggerAppRedirectClient(event) {
    event.preventDefault();

    // Get current URL parameters
    const urlParams = new URLSearchParams(window.location.search);

    // Add referrer if not present
    if (!urlParams.has('referrer')) {
      urlParams.append('referrer', 'web_calculator');
    }

    // Open app if on mobile, otherwise open web app
    if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      window.location.href = `jinglepay://transfer?${urlParams.toString()}`;

      // Fallback to app store after delay
      setTimeout(() => {
        const isAndroid = /Android/i.test(navigator.userAgent);
        window.location.href = isAndroid
          ? 'https://play.google.com/store/apps/details?id=com.jinglepay.app'
          : 'https://apps.apple.com/ae/app/jinglepay/id1545933506';
      }, 1000);
    } else {
      // Desktop - open web version
      window.open(`https://app.jinglepay.com/transfer?${urlParams.toString()}`, '_blank');
    }
  }

  console.log('MinimalTransferCalculator script loaded', {
    supportedCountries,
    sendCurrency,
    receiveCurrency,
    clientHelperAvailable: typeof getRemittanceRatesClient === 'function',
  });

  // Initialize state
  let state = {
    sendCurrency,
    receiveCurrency,
    countries: supportedCountries,
    isLoading: false,
  };

  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing calculator...');
    initCalculator();
  });

  function initCalculator() {
    console.log('Initializing calculator with state:', state);
    console.log('Client API functions available:', {
      getRemittanceRatesClient: typeof getRemittanceRatesClient === 'function',
      triggerAppRedirectClient: typeof triggerAppRedirectClient === 'function',
    });

    // Setup country dropdown
    setupCountryDropdown();

    // Setup amount input event
    setupAmountInput();

    // Setup send button
    setupSendButton();

    // Trigger initial calculation
    console.log('Triggering initial calculation with amount:', sendAmount);
    calculateExchange(sendAmount);
  }

  function calculateExchange(amount) {
    console.log('calculateExchange called');

    // Get DOM elements
    const sendInput = document.querySelector('[data-send-input]');
    const receiveInput = document.querySelector('[data-receive-input]');
    const transferFeeEl = document.getElementById('transfer-fee');
    const exchangeRateEl = document.getElementById('exchange-rate');

    console.log('Elements found:', {
      sendInput: !!sendInput,
      receiveInput: !!receiveInput,
      transferFeeEl: !!transferFeeEl,
      exchangeRateEl: !!exchangeRateEl,
    });

    if (!sendInput || !receiveInput || !transferFeeEl || !exchangeRateEl) {
      console.error('Required DOM elements not found');
      return;
    }

    // Parse amount
    const sendAmount = parseFloat(amount);
    console.log('Send amount parsed:', sendAmount);

    if (isNaN(sendAmount) || sendAmount <= 0) {
      if (receiveInput instanceof HTMLInputElement) receiveInput.value = '0.00';
      transferFeeEl.textContent = 'N/A';
      exchangeRateEl.textContent = 'N/A';
      return;
    }

    // Set loading state
    state.isLoading = true;
    console.log('Loading state set');

    // Prepare request payload
    const payload = {
      quotation_mode: 'SEND_AMOUNT',
      send: {
        amount: sendAmount,
        currency: state.sendCurrency,
        country_code: state.countries.find((c) => c.currency === state.sendCurrency)?.code || 'AE',
      },
      receive: {
        currency: state.receiveCurrency,
        country_code: state.countries.find((c) => c.currency === state.receiveCurrency)?.code || 'US',
      },
    };

    // Check if client API function is available
    if (typeof getRemittanceRatesClient !== 'function') {
      console.error('getRemittanceRatesClient is not a function!', typeof getRemittanceRatesClient);
      state.isLoading = false;
      if (receiveInput instanceof HTMLInputElement) receiveInput.value = '0.00';
      transferFeeEl.textContent = 'API Error';
      exchangeRateEl.textContent = 'API Error';
      return;
    }

    // Make API call with client-side function
    getRemittanceRatesClient('AE', payload)
      .then((response) => {
        console.log('API response received:', response);
        state.isLoading = false;

        if (response.__apiError) {
          console.error('API error:', response.errorMessage);
          if (receiveInput instanceof HTMLInputElement) receiveInput.value = '0.00';
          transferFeeEl.textContent = 'API Error';
          exchangeRateEl.textContent = 'API Error';
          return;
        }

        // Update UI with response
        const receiveAmount = response.receive.amount.toFixed(2);
        if (receiveInput instanceof HTMLInputElement) receiveInput.value = receiveAmount;

        // Update fee and rate
        transferFeeEl.textContent = `${response.fee.amount.toFixed(2)} ${response.fee.currency}`;

        if (response.quotations && response.quotations.length > 0) {
          const rate = response.quotations[0].transfer_fx_rate;
          exchangeRateEl.textContent = `1.00 ${state.sendCurrency} = ${rate.toFixed(4)} ${state.receiveCurrency}`;
        } else {
          exchangeRateEl.textContent = 'N/A';
        }
      })
      .catch((error) => {
        console.error('API error:', error);
        state.isLoading = false;
        if (receiveInput instanceof HTMLInputElement) receiveInput.value = '0.00';
        transferFeeEl.textContent = 'Error';
        exchangeRateEl.textContent = 'Error';
      });
  }

  function setupAmountInput() {
    const sendInput = document.querySelector('[data-send-input]');

    if (!sendInput || !(sendInput instanceof HTMLInputElement)) {
      console.error('Send input not found or is not an input element');
      return;
    }

    // Set initial value
    sendInput.value = sendAmount;

    // Setup input event
    sendInput.addEventListener('input', (event) => {
      if (!(event.target instanceof HTMLInputElement)) return;

      const value = event.target.value;
      // Remove non-numeric characters except decimal point
      const numericValue = value.replace(/[^0-9.]/g, '');

      // Ensure only one decimal point
      const parts = numericValue.split('.');
      if (parts.length > 2) {
        event.target.value = parts[0] + '.' + parts.slice(1).join('');
      }

      calculateExchange(event.target.value);
    });
  }

  function setupCountryDropdown() {
    console.log('Setting up dropdown with countries:', state.countries);

    const dropdown = document.getElementById('currency-dropdown');
    const button = document.getElementById('currency-dropdown-btn');
    const currencyText = document.getElementById('receive-currency-text');

    if (!dropdown || !button || !currencyText) {
      console.error('Dropdown elements not found');
      return;
    }

    // Clear previous options
    dropdown.innerHTML = '';

    // Add each country to dropdown
    state.countries.forEach((country) => {
      const option = document.createElement('div');
      option.className = 'p-2 hover:bg-gray-100 cursor-pointer';
      option.innerHTML = `
        <span class="mr-2">${country.flag || 'üè≥Ô∏è'}</span>
        <span>${country.name || country.code}</span>
        <span class="ml-2 text-gray-500">${country.currency}</span>
      `;

      option.addEventListener('click', () => {
        state.receiveCurrency = country.currency;
        currencyText.textContent = country.currency;
        dropdown.classList.add('hidden');

        // Update calculation with new currency
        const sendInput = document.querySelector('[data-send-input]');
        if (sendInput && sendInput instanceof HTMLInputElement) {
          calculateExchange(sendInput.value);
        }
      });

      dropdown.appendChild(option);
    });

    // Toggle dropdown on button click
    button.addEventListener('click', () => {
      dropdown.classList.toggle('hidden');
      button.setAttribute('aria-expanded', dropdown.classList.contains('hidden') ? 'false' : 'true');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (event) => {
      if (!(event.target instanceof Node)) return;

      if (!dropdown.contains(event.target) && !button.contains(event.target)) {
        dropdown.classList.add('hidden');
        button.setAttribute('aria-expanded', 'false');
      }
    });
  }

  function setupSendButton() {
    const sendButton = document.getElementById('send-btn');

    if (!sendButton) {
      console.error('Send button not found');
      return;
    }

    sendButton.addEventListener('click', (event) => {
      const sendInput = document.querySelector('[data-send-input]');
      const receiveInput = document.querySelector('[data-receive-input]');

      if (!sendInput || !receiveInput) {
        console.error('Input elements not found');
        return;
      }

      console.log('Send button clicked with values:', {
        sendAmount: sendInput instanceof HTMLInputElement ? sendInput.value : 'unknown',
        sendCurrency: state.sendCurrency,
        receiveAmount: receiveInput instanceof HTMLInputElement ? receiveInput.value : 'unknown',
        receiveCurrency: state.receiveCurrency,
      });

      // Use client-side redirect function
      if (typeof triggerAppRedirectClient === 'function') {
        triggerAppRedirectClient(event);
      } else {
        console.error('triggerAppRedirectClient function not available');
        alert('App redirect not available. Please try again later.');
      }
    });
  }
</script>
