---
/**
 * UAE Card Features Section – Virtual Cards / Security / Numberless
 * Pixel-perfect implementation of multi-card carousel with center focus
 */
import { Image } from 'astro:assets';
// Using existing image assets - consider replacing with assets that match the design
import virtualCardImg from '../../assets/uae/cards/virtual-cards.png';
import securityImg from '../../assets/uae/cards/security.png';
import numberlessImg from '../../assets/uae/cards/numberless.png';

const { cardFeatures } = Astro.locals.translations;

// Define the structure of a card feature
interface CardFeature {
  title: string;
  desc: string;
  img?: any;
  id?: number;
}

// Images for features
const featureImages = [virtualCardImg, securityImg, numberlessImg];

// Combine translations with images
const features = (
  cardFeatures?.features ||
  ([
    {
      title: 'Virtual Cards',
      desc: 'Unlock your freedom with a versatile debit card! Enjoy a joining bonus and earn cashback on every transaction.',
    },
    {
      title: 'Security',
      desc: 'Your personal data, money, and card details are stored securely with end-to-end encryption.',
    },
    {
      title: 'Numberless',
      desc: 'The cards only display your name – keeping your card details secure and further strengthening privacy.',
    },
  ] as CardFeature[])
).map((feature: CardFeature, index: number) => ({
  ...feature,
  img: featureImages[index],
  id: index,
}));

// Set initial active slide
const initialActiveIndex = 0;
---

<section class='flex justify-center w-full py-12 sm:py-24'>
  <div class='relative w-full px-4 max-w-7xl'>
    <!-- Carousel Container with Multiple Cards Visible -->
    <div class='relative overflow-hidden carousel-wrapper'>
      <div class='flex transition-all duration-500 carousel-track' id='cardFeatureSlides'>
        <!-- Add spacer at the beginning to allow proper centering -->
        <div class='carousel-spacer min-w-[calc(50%-150px)] sm:min-w-[calc(50%-250px)]'></div>

        {
          features.map((feature: CardFeature, index: number) => (
            <div
              class:list={[
                'carousel-slide flex-shrink-0 w-[300px] sm:w-[500px] px-2 sm:px-4 transform transition-all duration-500 ease-in-out',
                index === initialActiveIndex ? 'opacity-100 scale-100 z-10' : 'opacity-70 scale-90 z-0',
              ]}
              data-slide-id={feature.id}
            >
              <article class='w-full py-4'>
                <div class='flex items-center justify-center w-full h-48 sm:h-64 mb-4 sm:mb-8 overflow-hidden'>
                  <Image
                    src={feature.img}
                    alt={feature.title}
                    class='object-contain w-auto h-full transition-transform transform'
                    width={400}
                    height={250}
                    loading='eager'
                  />
                </div>
                <h3 class='mb-2 sm:mb-3 text-xl sm:text-2xl font-semibold text-left text-slate-800'>{feature.title}</h3>
                <p class='max-w-md text-sm sm:text-base leading-relaxed text-left text-slate-600'>{feature.desc}</p>
              </article>
            </div>
          ))
        }

        <!-- Add spacer at the end to allow proper centering -->
        <div class='carousel-spacer min-w-[calc(50%-150px)] sm:min-w-[calc(50%-250px)]'></div>
      </div>
    </div>

    <div class='flex items-center justify-center w-full'>
      <div class='flex items-center justify-between gap-3 sm:gap-6 px-3 sm:px-6 mt-4 sm:mt-8'>
        <!-- Left Arrow Button -->
        <button
          id='prevSlide'
          class='p-2 rounded-[100px] outline-1 outline-offset-[-1px] outline-violet-500 inline-flex justify-start items-center gap-2.5 focus:outline-none z-20'
          aria-label='Previous slide'
        >
          <svg
            width='24'
            height='24'
            viewBox='0 0 24 24'
            fill='none'
            xmlns='http://www.w3.org/2000/svg'
            class='text-violet-500'
          >
            <path d='M19 12H5' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'
            ></path>
            <path
              d='M12 19L5 12L12 5'
              stroke='currentColor'
              stroke-width='2'
              stroke-linecap='round'
              stroke-linejoin='round'></path>
          </svg>
        </button>

        <!-- Pagination Dots -->
        <div class='flex items-center space-x-2 sm:space-x-3'>
          {
            features.map((feature: CardFeature, i: number) => (
              <button
                class:list={[
                  'rounded-full transition-colors',
                  i === initialActiveIndex ? 'w-4 h-4 sm:w-5 sm:h-5 bg-violet-500' : 'w-3 h-3 sm:w-4 sm:h-4 bg-gray-300',
                ]}
                data-slide-dot={i}
                aria-label={`Go to slide ${i + 1}`}
              />
            ))
          }
        </div>

        <!-- Right Arrow Button -->
        <button
          id='nextSlide'
          class='p-2 rounded-[100px] outline-1 outline-offset-[-1px] outline-violet-500 inline-flex justify-start items-center gap-2.5 focus:outline-none z-20'
          aria-label='Next slide'
        >
          <svg
            width='24'
            height='24'
            viewBox='0 0 24 24'
            fill='none'
            xmlns='http://www.w3.org/2000/svg'
            class='text-violet-500'
            style='transform: rotate(180deg);'
          >
            <path d='M19 12H5' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'
            ></path>
            <path
              d='M12 19L5 12L12 5'
              stroke='currentColor'
              stroke-width='2'
              stroke-linecap='round'
              stroke-linejoin='round'></path>
          </svg>
        </button>
      </div>
    </div>
    <!-- New Navigation Arrows and Dots -->
  </div>
</section>

<script is:inline>
  // Enhanced carousel functionality with mouse drag and touch support
  document.addEventListener('DOMContentLoaded', () => {
    const track = document.getElementById('cardFeatureSlides');
    const slides = Array.from(document.querySelectorAll('.carousel-slide'));
    const prevButton = document.getElementById('prevSlide');
    const nextButton = document.getElementById('nextSlide');
    const dots = document.querySelectorAll('[data-slide-dot]');
    const wrapper = document.querySelector('.carousel-wrapper');

    let currentSlide = 0;
    const slideCount = slides.length;
    
    // Setup initial slide size - should match the CSS width (responsive)
    let slideWidth = 500; // Default width
    
    // Determine initial width based on screen size
    if (window.innerWidth <= 576) {
      slideWidth = 300;
    }
    
    // Update slideWidth when window resizes
    window.addEventListener('resize', () => {
      if (window.innerWidth <= 576) {
        slideWidth = 300;
      } else {
        slideWidth = 500;
      }
      updateTrackPosition(); // Reposition after resize
    });

    // Variables for drag handling
    let isDragging = false;
    let startPos = 0;
    let currentTranslate = 0;
    let prevTranslate = 0;
    let animationID = 0;
    let dragStartTime = 0;
    let dragEndTime = 0;

    // Debug to console - helps troubleshoot
    console.log('Carousel initialized with', slideCount, 'slides');

    function updateSlideVisibility() {
      // Update all slides to reflect their position relative to current
      slides.forEach((slide, index) => {
        // Handle as regular HTMLElement to avoid TypeScript issues
        const slideElement = slide;

        if (index === currentSlide) {
          // Active slide
          slideElement.classList.remove('opacity-70', 'scale-90');
          slideElement.classList.add('opacity-100', 'scale-100', 'z-10');
        } else {
          // Non-active slide
          slideElement.classList.remove('opacity-100', 'scale-100', 'z-10');
          slideElement.classList.add('opacity-70', 'scale-90', 'z-0');
        }
      });
    }

    function updateTrackPosition() {
      if (!track) return;

      // Calculate position to center the current slide
      const offset = currentSlide * slideWidth;

      // Apply transform to center the active slide
      currentTranslate = -offset;
      prevTranslate = -offset;
      setSliderPosition();
      console.log('Updated track position:', -offset, 'px');
    }

    function setSliderPosition() {
      if (!track) return;
      track.style.transform = `translateX(${currentTranslate}px)`;
    }

    function updateDots() {
      dots.forEach((dot, index) => {
        if (index === currentSlide) {
          dot.classList.remove('bg-gray-300');
          dot.classList.remove('w-3', 'h-3', 'sm:w-4', 'sm:h-4');
          dot.classList.add('bg-violet-500');
          dot.classList.add('w-4', 'h-4', 'sm:w-5', 'sm:h-5');
        } else {
          dot.classList.remove('bg-violet-500');
          dot.classList.remove('w-4', 'h-4', 'sm:w-5', 'sm:h-5');
          dot.classList.add('bg-gray-300');
          dot.classList.add('w-3', 'h-3', 'sm:w-4', 'sm:h-4');
        }
      });
    }

    function goToSlide(slideIndex) {
      // Handle circular navigation
      if (slideIndex < 0) {
        currentSlide = slideCount - 1;
      } else if (slideIndex >= slideCount) {
        currentSlide = 0;
      } else {
        currentSlide = slideIndex;
      }

      console.log('Going to slide', currentSlide);
      updateSlideVisibility();
      updateTrackPosition();
      updateDots();
    }

    // Mouse events for drag functionality
    function touchStart(event) {
      // Get the appropriate client position based on event type
      const clientX = event.type.includes('mouse') ? event.clientX : event.touches[0].clientX;

      startPos = clientX;
      isDragging = true;
      dragStartTime = new Date().getTime();

      // Stop any ongoing animation
      cancelAnimationFrame(animationID);

      // Add event listeners for move and end events
      if (event.type === 'mousedown') {
        document.addEventListener('mousemove', touchMove);
        document.addEventListener('mouseup', touchEnd);
      }

      // Change cursor to grabbing during drag
      if (track) track.style.cursor = 'grabbing';
    }

    function touchMove(event) {
      if (!isDragging) return;

      // Get the appropriate client position based on event type
      const clientX = event.type.includes('mouse') ? event.clientX : event.touches[0].clientX;

      const currentPosition = clientX;
      const diff = currentPosition - startPos;

      // Update current translate based on drag distance
      currentTranslate = prevTranslate + diff;

      // Apply the translation to the track
      animationID = requestAnimationFrame(() => {
        setSliderPosition();
      });
    }

    function touchEnd() {
      isDragging = false;
      dragEndTime = new Date().getTime();
      const dragDuration = dragEndTime - dragStartTime;

      // Calculate the distance moved
      const moveDistance = currentTranslate - prevTranslate;
      const swipeThreshold = 100; // Minimum distance to consider a swipe
      const fastSwipeTimeThreshold = 300; // ms threshold for a fast swipe

      cancelAnimationFrame(animationID);

      // Check if movement was significant enough to change slides
      const isSignificantMovement = Math.abs(moveDistance) > swipeThreshold;
      const isFastSwipe = Math.abs(moveDistance) > 20 && dragDuration < fastSwipeTimeThreshold;

      if (isSignificantMovement || isFastSwipe) {
        // If moved enough distance or was a fast swipe
        if (moveDistance > 0) {
          goToSlide(currentSlide - 1);
        } else {
          goToSlide(currentSlide + 1);
        }
      } else {
        // Snap back to current slide if movement wasn't enough
        goToSlide(currentSlide);
      }

      // Cleanup event listeners
      document.removeEventListener('mousemove', touchMove);
      document.removeEventListener('mouseup', touchEnd);

      // Reset cursor
      if (track) track.style.cursor = 'grab';
    }

    // Add mouse and touch event listeners to track
    if (track) {
      // Set initial cursor and make the carousel feel more interactive
      track.style.cursor = 'grab';

      // Apply styles to improve drag feel
      track.style.userSelect = 'none'; // Prevent text selection during drag

      // Mouse events with preventDefault to ensure smooth dragging
      track.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Prevent default browser drag behavior
        touchStart(e);
      });

      // Touch events
      track.addEventListener('touchstart', touchStart, { passive: true });
      track.addEventListener('touchmove', touchMove, { passive: true });
      track.addEventListener('touchend', touchEnd);

      // Prevent context menu which can interfere with dragging
      track.addEventListener('contextmenu', (e) => e.preventDefault());

      // Prevent dragging images, which can interfere with the carousel drag
      const images = track.querySelectorAll('img');
      images.forEach((img) => {
        img.setAttribute('draggable', 'false');
        img.style.pointerEvents = 'none'; // Prevent image interference with drag
      });
    }

    // Set up pagination dots event listeners
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        goToSlide(index);
      });
    });
    
    // Initialize the carousel
    updateSlideVisibility();
    updateTrackPosition();
    updateDots();

    // Set up button event handlers
    if (prevButton) {
      console.log('Previous button found, attaching handler');
      prevButton.addEventListener('click', () => {
        console.log('Previous button clicked');
        goToSlide(currentSlide - 1);
      });
    }

    if (nextButton) {
      console.log('Next button found, attaching handler');
      nextButton.addEventListener('click', () => {
        console.log('Next button clicked');
        goToSlide(currentSlide + 1);
      });
    }

    // Pagination dots
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        console.log('Dot', index, 'clicked');
        goToSlide(index);
      });
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        console.log('Left arrow pressed');
        goToSlide(currentSlide - 1);
      }
      if (e.key === 'ArrowRight') {
        console.log('Right arrow pressed');
        goToSlide(currentSlide + 1);
      }
    });
  });
</script>
